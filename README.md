# Kotlinで記述するデザインパターンの学習

* Iterator
* Adapter: 
     * すでに提供されているものを利用可能な状態にする
     * 拡張機能(例：既存APIver1 + 新規APIver2)として実装したい箇所に集中する
* Template Method:
    1. 抽象クラスで抽象メソッドとそのメソッドを用いたテンプレートメソッドを定義する。
    1. 具象クラスで実装する
    1. 具象クラスを呼び出し、抽象クラスの型に代入してメソッドを呼び出す(変更があった際は抽象クラスのメソッドを修正させるため)
    * サブクラスでアルゴリズムを記述する手間がかからない
    * 処理に順序が存在する場合に特に威力を発揮する
    * 処理の実装を伴うため、インターフェースではなく抽象クラスを用いる
* Factory Method:
    * インスタンス生成の枠組み（フレームワーク）を決めるパターン
    * インスタンスを生成するFactory、Factoryから生成されるインスタンスProductをフレームワークパッケージとして用意（両者は抽象クラス）
    * ConcreteProduct生成クラスとConcreteFactoryクラスを用意して上記フレームワークを実装する
    * 利用者はProductがどのような手順でインスタンスが生成されているかを知らずにすむ
    * newによるインスタンス生成をメソッド呼び出しに変えることで、具体的なクラス名による束縛からスーパークラスを解放している。
    *フレームワークのパッケージはConcreteクラスの内容に依存しないため、Concreteクラスは使い回しがきく
* Singleton:
    * インスタンスの生成を1つにする
    * このパターンを持ちるべきかどうか議論があるので保留
* Prototype:
    * 雛形クラスをnewすることなく、そのインスタンスを複製するパターン
    * 種類ごとにクラスを作成する必要がなくなる
    * 図形を表すインスタンスなど、インスタンス生成が難しい場合にも用いる
    * インスタンス複製を行う部分をframeworkのパッケージに配置し、複製メソッドにインスタンス生成のための名前を指定することでクラス名に依存しなくなる
* Builder:
    * インスタンス生成と作成過程を制御するパターン
    * インスタンス生成を制御する形式を決定するBuilder役クラスと、インスタンス作成過程を表現するDirector役クラスとを組み合わせる
    * Builderクラスを継承（実装）したサブクラスのインスタンスをDirectorがBuilderクラスとして受け取るため、サブクラスの交換可能性が明確になる
    * Template Methodはスーパークラスがサブクラスをコントロールする。BuilderはDirectorがBuilder役をコントロールする
* Abstract Factory:
    * 関連するオブジェクト郡をまとめて生成するための手順の抽象化
    * 抽象的な部品と工場、またそれぞれに対応する具体的なクラスを用意する
* Bridge:
    * 機能と実装のクラス階層を分けることでソースコードの修正箇所を最小限するパターン。例えばあるプログラムにOS依存の箇所がある場合、実装クラス階層で表現する。
    * Abstraction（抽象化）がImplementor（実装者）を保持する
    * RefinedAbstraction（改善した抽象化）がAbstractionに機能追加したクラス
    * ConcreteImplementorがImplementorのAPIを実装する
* Strategy:
    * アルゴリズムなどのインターフェースを切り替えるパターン。
    * 委譲を行うことでインターフェースの動的な切り替えを可能にする。
* Composite:
    * 容器と中身を同一視する再帰的構造を作るパターン。
    * 複数個の物を集めてあたかも一つのように扱う。
    * Leaf(中身)：他の物を入れられない役。
    * Composite（複合体）：Leaf, Compositeを入れる。CompositeがCompositeをもつ再帰的構造である場合も想定される。
    * Component：Leaf, Compositeを同一視するスーパークラス。
* Visitor:
  * データ構造と処理を分離し、データ構造の中を渡り歩く「訪問者」を表すクラスを用意し、そのクラスに処理を任せる。
* State:
  * 状態をStateインターフェースを実装した各クラスとして定義し、状態遷移はそのクラスを切り替えることで実現する。
  * 状態の管理を行うContextクラスがState（インターフェース）をメンバ変数として持ち、状態に応じた振る舞いを各State実装クラスに委譲する。
  * 実装クラスがContextクラスへの参照を保持している。　※ここ大事！
  * 実装クラスは状態の選択とContextクラスのメソッドをの呼び出しを、参照を通して行う。